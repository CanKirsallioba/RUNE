GROUP NUMBER:	33

LANGUAGE NAME:	RUNE

GRADE:		83/100



PART A:-15

PART B:

PART C:-2



-------------------------------PART A - LANGUAGE DESIGN (40)------------------------------

-2 BNF Syntax

*Check for similar cases

<read_inclination_function> defined but not used in BNF.

<read_altitude_function> defined but not used in BNF.

<do_flip_function> defined but not used in BNF.

*You are expected to use BNF as it is written in the project website.Check for similar cases.

<basic_equality> ::= (INT | FLOAT | BOOLEAN | IDENTIFIER | <function_call>) (EQUAL | NOT_EQUAL)

<basic_equality> ::= (INT | FLOAT | BOOLEAN | IDENTIFIER | <function_call>) (EQUAL | NOT_EQUAL)

(INT | FLOAT | BOOLEAN | IDENTIFIER | <function_call>)



-1 End up with same identifier: This is ambiguous. Since <logical_expression> and <expr> result in <function_call>, it leads to multiple parse trees. Check similar cases if you have.

<assignment> ::= IDENTIFIER ASSIGNMENT_OPERATOR <expression>

| <data_type> IDENTIFIER ASSIGNMENT_OPERATOR <expression>

<expr> ::= INT

| FLOAT

| <function_call>

| <logical_expression> | IDENTIFIER

<logical_expression> ::= BOOLEAN

| <comparison>

| <basic_equality>

| <function_call>



-2 Missing precedence rules for logical operations

<logical_expression> ::=

| <logical_expression> AND <logical_expression> | <logical_expression> OR <logical_expression>



-1 This is ambiguous. Check the unambiguity rules for BNF.Check for similar cases.

<logical_expression> ::=  <logical_expression> AND <logical_expression>



-1 Why are putting values inside your input body? Input statement should get input from a user.Able to get input from user such as var = input() or input(var) that stores the input taken from user to var.

<input_statement> ::= SCAN LP<expression> RP SEMICOLON



-5 Writability

* Defining variables and Assignment: not possible to do assignments such as:

variable = primitive function



* Output statement: output statement print the given content to the console, it should be possible to output:

output(primitive function)

<output_statement> ::= PRINT LP <expression> RP SEMICOLON



* Function Definition: since you have types(int, string, set, etc.) in your language, you need to specify them while defining function parameters

<void_with_return> ::= VOID_TYPE IDENTIFIER LP <argument_list> RP LCB <statement_list> <void_return_statement> RCB

<argument> ::= INT

| FLOAT

| CHAR

| BOOLEAN

| IDENTIFIER

| <function_call>



-3 Reliability

* Function Call: lead parameters such as (1,)

<function_call> ::= IDENTIFIER LP <argument_list> RP

<argument_list> ::= <argument> COMMA <argument_list> | <argument>

| empty

<argument> ::= INT

| FLOAT

| CHAR

| BOOLEAN

| IDENTIFIER

| <function_call>



* Function Definition: lead parameters such as (var,)

<void_with_return> ::= VOID_TYPE IDENTIFIER LP <argument_list> RP LCB <statement_list> <void_return_statement> RCB

<argument> ::= INT

| FLOAT

| CHAR

| BOOLEAN

| IDENTIFIER

| <function_call>





-----------------------------PART B - LEXICAL ANALYSIS (30)-------------------------------



-------------------------------PART C - EXAMPLE PROGRAM (30)------------------------------



-2 Inconsistency between BNF and example

*This is not possible with your BNF since <read_temperature_function> is not used in BNF.

readTemperature();

*This is not possible with your BNF 

int temperature <- readTemperature();

*This is not possible with your BNF 

up(60);

setSpeed(5);

*This is not possible with your BNF

if (readAltitude() > 20){...}



Further Improvement:

*Tokens defined in Lex should not be defined in BNF again. Their tokens should be used in BNF. For instance, if you have a token as IDENTIFIER in Lex, you can directly use IDENTIFIER in BNF. You don't need to define identifier in BNF with a non-terminal <identifier>.



*As a reminder, check your BNF for possible ambiguity problems that leads your grammar to have multiple parse tree. 



*SDK and sample videos are given to give you some idea about the interface of the drone. Therefore, you only need to have the primitive functions defined in Part A. It is written to inform you about the necessities of the language, you can keep them if you want.
